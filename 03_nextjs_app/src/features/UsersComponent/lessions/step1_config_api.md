### Крок 1: Перенесення конфігурації та API запитів

На цьому етапі ми перенесли базову конфігурацію та функції для роботи з API з React-додатка до Next.js.

#### Що було зроблено:
1. Створено нову структуру папок у `src/features/UsersComponent`.
2. Перенесено файл `config.ts` з URL-адресою API та значеннями за замовчуванням.
3. Перенесено папку `api/` з усіма функціями запитів (`fetchUserList`, `fetchUserById` тощо).
4. Файли було адаптовано для використання у TypeScript-проєкті (змінено розширення на `.ts` та оновлено імпорти).

#### Порівняння: React vs Next.js

| Характеристика | React (Client-side) | Next.js (App Router) |
| :--- | :--- | :--- |
| **Місце виконання запиту** | Виключно в браузері користувача (Client-side). | Може виконуватися як на сервері (Server Components), так і в браузері (Client Components). |
| **Управління даними** | Потребує `useEffect` та станів (`useState`) або сторонніх бібліотек (React Query, SWR) для управління станом завантаження та помилками. | У серверних компонентах дані можна отримувати за допомогою `async/await` прямо в тілі компонента. Менше "бойлерплейту" (немає потреби в `useEffect`). |
| **Кешування** | Потрібно реалізовувати самостійно або використовувати сторонні інструменти. | Next.js має розширений вбудований механізм кешування для `fetch`, що дозволяє легко налаштовувати час життя даних (revalidation). |
| **Конфігурація** | Зазвичай зберігається в `process.env`, доступ до якого має бути відкритий для клієнта (через префікси на кшталт `REACT_APP_`). | Дозволяє розділяти змінні оточення на "публічні" (з префіксом `NEXT_PUBLIC_`) та "секретні" (доступні тільки на сервері). |

**Висновок:**
Хоча самі функції запитів виглядають ідентично, спосіб їх використання в Next.js кардинально змінюється завдяки можливості виконання коду на сервері. Це дозволяє зменшити кількість коду на клієнті та покращити продуктивність (SEO та швидкість першого завантаження).
