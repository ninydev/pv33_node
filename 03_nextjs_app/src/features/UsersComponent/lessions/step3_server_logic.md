### Крок 3: Перенесення логіки на сторону сервера та пагінація

У цьому кроці ми реалізували основну сторінку списку користувачів, використовуючи можливості Next.js Server Components.

#### 1. Відмова від хуків на користь серверного отримання даних
У чистому React ми використовували хук `useUsersList`, який керував станами `isLoading`, `users` та `error` через `useState` та `useEffect`.

**Як це було в React:**
- Компонент рендериться порожнім (або з лоадером).
- Викликається `useEffect`.
- Робиться запит з браузера.
- Стан оновлюється, компонент перемальовується.

**Як це працює в Next.js (Server Side):**
- Ми просто оголошуємо компонент як `async`.
- Викликаємо `fetchUserList` прямо в тілі компонента.
- Next.js чекає виконання запиту на сервері та віддає браузеру вже готову HTML-сторінку з даними.
- **Результат:** Менше коду, краще SEO, відсутність "мерехтіння" при завантаженні.

#### 2. Пагінація через URL
Ми перенесли стан поточної сторінки з `useState` в URL-шлях: `/users/page/[page]`.
Це дозволяє:
- Користувачам ділитися посиланням на конкретну сторінку.
- Покращує індексацію сторінок пошуковими роботами.
- Реалізувати навігацію через звичайні посилання (`Link`), що працюють швидше та надійніше.

#### 3. Попередня генерація сторінок (SSG)
Ми використали функцію `generateStaticParams` для того, щоб Next.js побудував перші сторінки списку під час збірки проєкту.
```typescript
export async function generateStaticParams() {
    return [{ page: '1' }, { page: '2' }, ...];
}
```
Це робить перехід між цими сторінками миттєвим.

#### Порівняння підходів

| Характеристика | React (Client-Side) | Next.js (Server-Side) |
| :--- | :--- | :--- |
| **Керування станом** | `useState`, `useEffect` | Параметри URL (`params`) |
| **Завантаження даних** | З браузера (після рендеру) | З сервера (під час рендеру) |
| **Код** | Більше (хуки, обробка завантаження) | Менше (прямий виклик асинхронних функцій) |
| **Навігація** | Зміна внутрішнього стану | Перехід за посиланням |

#### 4. Важливість строгої типізації
При роботі в серверних компонентах важливо явно вказувати типи для змінних, які ініціалізуються порожніми значеннями, щоб уникнути помилок `implicit any`.
```typescript
let users: User[] = [];
let error: string | null = null;
```
Це гарантує, що TypeScript зможе правильно перевірити використання цих змінних у JSX та інших частинах логіки.

---
**Наступний крок:** Робота з формами та Server Actions для створення/редагування.
