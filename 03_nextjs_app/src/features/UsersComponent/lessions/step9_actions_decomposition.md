### Крок 9: Декомпозиція Server Actions

У цьому кроці ми провели рефакторинг нашого коду, розділивши один великий файл `actions.ts` на окремі модулі в папці `actions/`. Це стандартна практика для великих проектів, яка покращує читабельність та полегшує підтримку коду.

#### 1. Чому декомпозиція важлива?
Коли проект розростається, один файл з усіма діями (создання, оновлення, видалення) стає важким для навігації. Розділення на частини дозволяє:
- **Легше знаходити потрібний код:** Кожна дія має свій власний файл.
- **Уникнути конфліктів при злитті (merge conflicts):** Розробники можуть працювати над різними діями одночасно в різних файлах.
- **Покращити тестування:** Кожну дію можна тестувати ізольовано.

#### 2. Нова структура папки `actions/`
Ми створили наступну структуру:
- `createUser.ts` — містить `createUserAction`.
- `updateUser.ts` — містить `updateUserAction`.
- `deleteUser.ts` — містить `deleteUserAction`.
- `index.ts` — реекспортує всі дії для зручного використання.

**Приклад `index.ts`:**
```typescript
export * from './createUser';
export * from './updateUser';
export * from './deleteUser';
```

#### 3. Використання `index.ts`
Завдяки файлу `index.ts`, нам не потрібно змінювати імпорти в усіх компонентах. Замість:
`import { createUserAction } from '../actions/createUser';`
Ми все ще можемо писати:
`import { createUserAction } from '../actions';`

TypeScript та Next.js автоматично шукають файл `index` у вказаній директорії.

#### 4. Порівняння з React
| Характеристика | React (Звичайний підхід) | Next.js (Декомпозиція Actions) |
| :--- | :--- | :--- |
| **Організація** | Логіка часто змішана з компонентами або в гігантських хуках. | Чіткий розподіл на серверні дії, кожна в своєму файлі. |
| **Масштабованість** | Важко підтримувати при великій кількості бізнес-логіки. | Легко додавати нові дії, не захаращуючи існуючий код. |
| **Читабельність** | Потрібно гортати сотні рядків коду. | Назви файлів говорять самі за себе. |

#### Підсумок
Тепер наш проект має професійну структуру. Кожен модуль відповідає за свою частину роботи (Single Responsibility Principle), що робить код чистішим та надійнішим.

---
**Наступний крок:** Оптимізація та робота з метаданими.
