### Крок 2: Типізація моделей та API

У цьому кроці ми додали сувору типізацію для наших даних та функцій API. Це один із ключових аспектів розробки на Next.js (який за замовчуванням використовує TypeScript) порівняно зі звичайним JavaScript у React.

#### 1. Створення моделі користувача
Ми створили файл `types.ts`, де описали інтерфейс `User` на основі даних з MockAPI.

```typescript
export interface User {
    id: string;
    createdAt: string;
    name: string;
    avatar: string;
    email: string;
    country: string;
    color: string;
    phone: string;
}
```

Також ми використали утиліти TypeScript для створення допоміжних типів:
- `UserCreateInput`: для створення нового користувача (без `id` та `createdAt`, які генерує сервер). Використовується `Omit<User, 'id' | 'createdAt'>`.
- `UserUpdateInput`: для оновлення існуючого користувача. Використовується `Partial<UserCreateInput>`.

#### 2. Переваги типізації
| Характеристика | JavaScript (React) | TypeScript (Next.js) |
| :--- | :--- | :--- |
| **Автодоповнення** | Обмежене, часто "вгадується" IDE. | Повне автодоповнення всіх полів об'єкта. |
| **Помилки** | Виявляються під час виконання (Runtime). | Виявляються на етапі написання коду або збірки (Compile-time). |
| **Документація** | Потрібно писати коментарі JSDoc. | Сам код є документацією. |

#### 3. Оновлення API
Тепер кожна функція чітко знає, що вона приймає і що повертає. Це запобігає передачі некоректних даних у запитах.

Приклад оновленої функції:
```typescript
export default async function fetchUserById(userId: string): Promise<User> {
    // ...
}
```

#### Чому це важливо в Next.js?
Оскільки Next.js часто виконує код на сервері (Server Components), помилки типізації можуть призвести до помилок під час рендерингу на стороні сервера. TypeScript дозволяє виявити ці проблеми ще до того, як код потрапить у браузер користувача.

---
**Наступний крок:** Перенесення логіки стану та хуків.
